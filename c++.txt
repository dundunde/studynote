c++可变参(Logger)
python 符号*的作用




在C/C++中，全局变量和静态全局变量主要区别在于作用域和链接属性，具体如下：

1. 作用域（可见性）
全局变量
默认具有外部链接（external linkage）：

在文件A中定义的全局变量，可以在文件B中通过extern声明后直接访问。

作用域跨多个源文件（整个程序）。

静态全局变量
通过static关键字修饰，具有内部链接（internal linkage）：

只能在定义它的文件内部访问。

其他文件无法通过extern声明访问它。

作用域仅限于当前文件。

2. 命名冲突
全局变量
不同文件中同名的全局变量会导致链接错误（重复定义）。
示例：

c
// File1.c
int globalVar = 10;  // 全局变量

// File2.c
int globalVar = 20;  // 错误！链接时冲突
静态全局变量
每个文件的静态全局变量是独立的，不会冲突。
示例：

c
// File1.c
static int staticGlobal = 10;  // 仅File1可见

// File2.c
static int staticGlobal = 20;  // 合法，仅File2可见
3. 内存分配与生命周期
两者相同：

都在静态存储区分配内存（程序启动时创建，结束时销毁）。

生命周期均为整个程序运行期间。

未显式初始化时，自动初始化为0（或NULL）。

4. 设计目的
全局变量
用于在多个文件间共享数据（需谨慎使用，易引发耦合问题）。

静态全局变量
实现文件级封装：

避免命名污染，提高模块化。

隐藏数据，仅限当前文件内使用（类似私有成员）。

示例代码
c
// FileA.c
int globalVar = 100;         // 全局变量（其他文件可访问）
static int staticVar = 200;  // 静态全局变量（仅FileA.c可访问）

// FileB.c
extern int globalVar;        // 正确：访问FileA的globalVar
extern int staticVar;        // 错误！无法访问FileA的staticVar
c
// FileC.c
static int staticVar = 300;  // 独立变量，与FileA的staticVar无关
总结
特性	全局变量	静态全局变量
关键字	无（或extern声明）	static
作用域	整个程序	仅定义它的文件
链接属性	外部链接（跨文件访问）	内部链接（文件内私有）
命名冲突	跨文件同名会冲突	文件间独立，无冲突
内存与生命周期	相同（静态存储区，全程存在）	相同
用途	跨文件共享数据	文件内封装，避免污染
关键点：静态全局变量通过static限制作用域，避免全局命名冲突，提升代码模块化。







析构函数可以带参数吗，析构函数可以重写吗，析构函数可以是纯虚函数吗，析构函数可以重载吗

析构函数可以带参数吗？

? 不可以。

析构函数绝对不能有任何参数。它的函数签名是严格定义的：~ClassName()。

原因：析构函数是由系统自动调用的（当对象离开作用域、被delete、或包含它的对象被析构时）。系统调用它时没有任何方式传递参数给它。因此，设计带参数的析构函数在语法上不允许，在逻辑上也行不通。

析构函数可以重写吗？

? 可以（通过虚函数机制）。

关键点在于virtual关键字：

如果基类的析构函数不是虚函数（virtual），那么通过基类指针删除派生类对象时，只会调用基类的析构函数，派生类的析构函数不会被调用。这会导致派生类特有的资源（如动态内存、文件句柄等）泄漏。

如果基类的析构函数被声明为虚函数（virtual ~BaseClass();），那么通过基类指针删除派生类对象时，会先调用派生类的析构函数，再调用基类的析构函数。这是正确的、预期的行为，确保了派生类资源被正确释放。

当派生类定义自己的析构函数时，它覆盖（override）了基类的虚析构函数。虽然我们常说“重写虚函数”，析构函数的覆盖遵循同样的虚函数机制。

结论： 为了让多态基类能安全地被继承和通过基类指针删除，基类的析构函数必须声明为virtual。派生类的析构函数会自动覆盖（重写）它。这就是析构函数“重写”的含义。

析构函数可以是纯虚函数吗？

? 可以，但有重要要求。

析构函数可以被声明为纯虚函数（virtual ~BaseClass() = 0;）。

作用： 将析构函数声明为纯虚函数的主要目的是使该类成为抽象基类，即不能直接实例化该类的对象，只能创建其派生类的对象。这强制要求用户必须从这个基类派生出具体的类。

关键要求： 纯虚析构函数必须提供实现（定义）！ 这与普通纯虚函数不同（普通纯虚函数通常没有实现）。

原因： 当一个派生类对象被析构时，其析构函数调用链是：派生类析构函数 -> 基类析构函数 -> ... -> 最顶层基类析构函数。即使基类的析构函数是纯虚的，系统仍然需要在析构派生类对象时调用这个基类的析构函数。如果只有纯虚声明而没有定义，链接器会报错（找不到该析构函数的实现）。

如何定义： 在类外提供纯虚析构函数的实现（即使函数体是空的）：

cpp
class AbstractBase {
public:
    virtual ~AbstractBase() = 0; // 纯虚声明
    // ... 其他纯虚或虚函数 ...
};
AbstractBase::~AbstractBase() { // 必须提供定义
    // 可以留空，但必须有这个定义
}



析构函数可以重载吗？
? 不可以。

原因分析：
语法限制：

析构函数的签名是严格固定的：~类名()，不允许有任何参数（既不能有普通参数，也不能有默认参数）。

重载要求函数名相同但参数列表不同。由于析构函数不能带参数，无法通过参数区分不同版本，因此无法重载。

语言设计原则：

析构函数由编译器自动调用（对象销毁时），调用时没有传递参数的机制。

一个类必须有且只有一个析构函数。如果允许多个析构函数，编译器无法确定该调用哪一个。







一个类的构造函数是explicit的，那么它可以使用=号来构造吗

在C++中，如果一个类的构造函数被声明为explicit，那么它不能直接使用=号进行拷贝初始化（即形如 ClassName obj = value; 的形式）。原因如下：

关键点：
explicit 的作用：

explicit 关键字用于防止编译器进行隐式类型转换。它要求构造必须显式调用（如直接使用括号 () 或花括号 {}），避免意外的转换。

= 号在初始化中的行为：

使用 = 的初始化（例如 ClassName obj = value;）称为拷贝初始化（copy initialization）。

拷贝初始化会尝试将 value 隐式转换为 ClassName 类型，这需要非 explicit 的构造函数支持。

如果构造函数是 explicit 的，拷贝初始化会导致编译错误，因为它禁止隐式转换。

代码示例：
cpp
class MyClass {
public:
    explicit MyClass(int x) { } // explicit 构造函数
};

int main() {
    MyClass obj1(42);    // 正确：直接初始化，允许 explicit 构造函数
    MyClass obj2{42};    // 正确：直接列表初始化（C++11 起），允许 explicit 构造函数

    // MyClass obj3 = 42; // 错误：拷贝初始化，explicit 构造函数禁止隐式转换
}
允许的初始化方式：
当构造函数是 explicit 时，可以使用以下方式：

直接初始化：ClassName obj(arg);

直接列表初始化（C++11 起）：ClassName obj{arg};

显式转换：ClassName obj = static_cast<ClassName>(arg);

例外情况：
C++17 起的多参数初始化：
如果类有多个参数，且使用 = 加花括号（例如 ClassName obj = {arg1, arg2};），这属于拷贝列表初始化（copy-list-initialization）。如果构造函数是 explicit 的，仍然不允许，因为涉及隐式转换。

cpp
// 假设有 explicit MyClass(int a, int b);
// MyClass obj = {1, 2}; // 错误：explicit 构造函数禁止此操作
总结：
不能使用 = 进行拷贝初始化（如 obj = value），因为 explicit 构造函数禁止隐式转换。

可以使用其他显式方式（如 obj(value) 或 obj{value}）。

如果需要 = 初始化，需移除构造函数的 explicit 关键字（但需谨慎，这会允许隐式转换）。





c++类中的static变量要在类外定义吗



在 C++ 中，类内的 static 成员变量必须在类外进行定义（分配存储空间），但可以在类内进行声明。以下是关键点：

1. 类内声明（必须）
在类内部使用 static 关键字声明变量：

cpp
class MyClass {
public:
    static int staticVar; // 声明（类内）
};
2. 类外定义（必须）
在类外部（通常在 .cpp 文件中）定义变量并分配存储空间：

cpp
int MyClass::staticVar = 42; // 定义（类外）
必须 在类外定义一次（且只能一次），否则会导致链接错误。

初始化值在定义时指定（如 = 42）。

例外情况：const static 整型/枚举类型（C++11 起扩展）
若静态成员是 常量整型（int、char、bool 等）或枚举类型，且编译器支持 C++11 或更高标准，可在类内直接初始化：

cpp
class MyClass {
public:
    static const int MAX_SIZE = 100; // ? 类内声明并初始化
};

// 类外定义（可选，但若需取地址则必须定义）
const int MyClass::MAX_SIZE; // 不带初始值（已在类内初始化）
注意：即使类内初始化了，若在代码中对该变量 取地址（如 &MyClass::MAX_SIZE），则仍需在类外定义（无需再初始化）。

为什么需要类外定义？
存储空间分配：静态成员不属于类的实例，而是类级别的全局变量。类内声明仅表明存在该变量，实际存储空间需通过类外定义分配。

避免链接错误：未定义时，编译器会报 undefined reference 错误。

示例代码
头文件 MyClass.h

cpp
#pragma once

class MyClass {
public:
    static int instanceCount; // 声明普通静态变量
    static const int MAX_SIZE = 100; // 声明并初始化常量静态整型
};
源文件 MyClass.cpp

cpp
#include "MyClass.h"

// 定义普通静态变量
int MyClass::instanceCount = 0; 

// 定义常量静态整型（若需取地址则必须定义）
const int MyClass::MAX_SIZE;
总结
类型	类内操作	类外操作
普通 static 变量	声明 static int var;	必须定义 int Class::var = value;
const static 整型/枚举	声明并初始化 static const int var = value;	可选定义（取地址时必须）
始终确保在 .cpp 文件中定义静态成员变量以避免链接错误！



还有哪些东西必须在类外定义


在 C++ 中，除了类的静态成员变量（static member variables）需要在类外定义外，还有以下几种情况也必须在类外进行定义：

1. 静态成员常量（非整型/非枚举）
对于非整型/非枚举类型的 static const 成员，必须在类外定义（即使类内已初始化）：

cpp
class MyClass {
public:
    static const double PI;  // 声明（类内）
};

// 必须在类外定义
const double MyClass::PI = 3.14159;
2. 类模板的静态成员
类模板的静态成员必须在类外定义，且需指定模板参数：

cpp
template<typename T>
class TemplateClass {
public:
    static T staticVar;  // 声明
};

// 类外定义（需在头文件中）
template<typename T>
T TemplateClass<T>::staticVar = T();  // 默认初始化
注意：C++17 起可用 inline 在类内定义，避免此要求。

3. 类的显式特化成员
当类模板的成员被显式特化时，特化版本必须在类外定义：

cpp
template<>
int TemplateClass<int>::staticVar = 100;  // 特化版本的类外定义
4. 类的静态常量（需取地址时）
即使 static const int 可在类内初始化，但若程序中需要取地址，则仍需在类外定义：

cpp
class MyClass {
public:
    static const int MAX = 100;  // 类内初始化
};

// 如果需要取地址（如 &MyClass::MAX），则必须定义
const int MyClass::MAX;  // 类外定义（不带初始值）
5. 非模板类的静态成员函数（仅当需要分离声明和实现时）
虽然静态成员函数可以在类内直接定义，但如果选择分离声明和实现，则必须在类外定义：

cpp
class MyClass {
public:
    static void staticFunc();  // 声明
};

// 类外定义（在 .cpp 文件中）
void MyClass::staticFunc() {
    // 实现
}
6. 类模板的成员函数（非内联）
类模板的成员函数若不在类内定义，则必须在类外定义（需包含完整模板语法）：

cpp
template<typename T>
class TemplateClass {
public:
    void memberFunc();  // 声明
};

// 类外定义
template<typename T>
void TemplateClass<T>::memberFunc() { 
    // 实现
}
总结：必须类外定义的情况
类型	示例
普通静态成员变量	int MyClass::staticVar = 0;
非整型静态常量	const double MyClass::PI = 3.14;
类模板的静态成员	template<typename T> T TemplateClass<T>::staticVar = T();
显式特化的静态成员	template<> int TemplateClass<int>::staticVar = 100;
需取地址的 static const int	const int MyClass::MAX;（类内已初始化）
分离实现的静态成员函数	void MyClass::staticFunc() { ... }
类模板的成员函数（非内联实现）	template<typename T> void TemplateClass<T>::func() { ... }
例外：C++17 的改进
C++17 引入 inline 变量，允许在类内直接定义静态成员变量（避免类外定义）：

cpp
class ModernClass {
public:
    inline static int count = 0;       // 整型
    inline static const double PI = 3.14159; // 非整型常量
};
这在头文件中尤其有用，可避免链接错误。


const变量可以在类内定义吗

在 C++ 中，const 变量能否在类内定义取决于它的类型和上下文。以下是详细的规则说明：

1. 非静态 const 成员变量
可以在类内直接初始化（C++11 起）：

cpp
class Widget {
public:
    const int width = 100;  // ? C++11 起允许（类内初始化）
    const std::string name = "default";
};
这相当于为构造函数提供默认值。

实际初始化发生在构造函数的初始化列表中（如果构造函数未显式初始化，则使用此默认值）。

C++11 之前：必须在构造函数的初始化列表中初始化：

cpp
// C++03 风格
class Widget {
public:
    const int width;
    Widget() : width(100) {} // 必须在初始化列表初始化
};
2. 静态 const 成员变量
整型或枚举类型：可在类内初始化（无需类外定义，除非需要取地址）：

cpp
class Settings {
public:
    static const int MAX_SIZE = 1024;  // ? 整型常量（类内初始化）
};
取地址时需要类外定义（不带初始值）：

cpp
const int Settings::MAX_SIZE; // 类外定义（在 .cpp 文件中）
非整型（如 double, std::string）：

C++17 前：必须类外定义（即使类内初始化）：

cpp
class Physics {
public:
    static const double GRAVITY; // 声明（类内）
};
// 类外定义（在 .cpp 文件中）
const double Physics::GRAVITY = 9.8;
C++17 起：可用 inline 在类内定义：

cpp
class Physics {
public:
    inline static const double GRAVITY = 9.8; // ? C++17
};
3. constexpr 静态成员（C++11 起）
任何类型都可在类内初始化：

cpp
class Constants {
public:
    static constexpr double PI = 3.1415926; // ? 非整型
    static constexpr const char* NAME = "Math";
};
C++17 前：如果取地址，仍需类外定义（不带初始值）：

cpp
constexpr double Constants::PI; // 类外定义（.cpp 文件）
C++17 起：无需类外定义（隐式 inline）。

总结表：const 变量在类内的定义规则
类型	是否可在类内初始化	额外要求
非静态 const 成员	? C++11 起	相当于构造函数默认值
静态 const 整型/枚举	?	取地址时需要类外定义
静态 const 非整型	? C++17 前
? C++17（需 inline）	C++17 前必须类外定义
constexpr 静态成员	?	C++17 前取地址时需要类外定义
C++17 起无需定义
示例代码
cpp
#include <string>

// 示例类（兼容 C++11）
class Example {
public:
    // ? 非静态 const 成员（C++11 起）
    const int id = 0;
    
    // ? 静态 const 整型
    static const int MAX = 100;
    
    // ? 静态 const 非整型（C++17 前需类外定义）
    static const double PI; 
    
    // ? constexpr 静态成员（C++11 起）
    static constexpr const char* NAME = "Example";
};

// 类外定义（在 .cpp 文件中）
const double Example::PI = 3.14159;
constexpr const char* Example::NAME; // C++17 前取地址时需要
关键点
非静态 const 成员：C++11 起支持类内初始化（实际在构造函数中初始化）。

静态 const：

整型：类内初始化 + 取地址时类外定义。

非整型：C++17 前必须类外定义，C++17 起用 inline 在类内定义。

constexpr 静态成员：类内初始化 + C++17 前取地址时需类外定义。

根据你的 C++ 标准版本和具体使用场景选择合适的初始化方式！










面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。
为了简化程序设计，面向过程把函数继续切分为子函数，
即把大块函数通过切割成小块函数来降低系统的复杂度。

而面向对象的程序设计把计算机程序视为一组对象的集合，
而每个对象都可以接收其他对象发过来的消息，并处理这些消息，
计算机程序的执行就是一系列消息在各个对象之间传递。







qt中，将一个类整个移动到新线程并通过信号与槽通讯
a(类实例）
thread(新线程)

a.moveToThread(&thread);
connect(xxx,信号，a,槽）；
thread.start();
当没有相关信号发送时，线程处于 阻塞状态
原因：
Qt 的 QThread 本质上是对操作系统线程的封装，其状态由「事件循环」的状态决定：
当调用start() 后，线程启动并进入 事件循环状态（QThread::Running）。
事件循环会等待「信号、定时器触发、网络事件」等事件，此时线程处于 等待（阻塞）状态（不占用 CPU 资源）。
当有事件触发（如定时器 timeout 信号），线程会从等待状态唤醒，执行对应的槽函数（fetchHardwareInfo），此时处于 运行状态。
槽函数执行完毕后，线程会再次回到 事件循环的等待状态，直到下一个事件触发。






